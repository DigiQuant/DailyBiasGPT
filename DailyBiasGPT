# -*- coding: utf-8 -*-
# Kerykeion v3.x compatible
from kerykeion import AstrologicalSubject, Report # Report is now primary for chart details
from datetime import datetime, timezone, timedelta
import math
import pprint
import inspect
try:
    from zoneinfo import ZoneInfo, ZoneInfoNotFoundError
    _use_zoneinfo = True
except ImportError:
    _use_zoneinfo = False
    try:
        import pytz
        _use_pytz = True
    except ImportError:
        _use_pytz = False
import traceback
from collections import defaultdict # Added for transit-to-transit aspect grouping

# --- Zodiac Rulers for House Lord Calculations ---
ZODIAC_RULERS = {
    "Ari": "Mars", "Tau": "Venus", "Gem": "Mercury", "Can": "Moon",
    "Leo": "Sun", "Vir": "Mercury", "Lib": "Venus", "Sco": "Mars", # Traditional: Mars, Modern: Pluto
    "Sag": "Jupiter", "Cap": "Saturn", "Aqu": "Saturn", # Traditional: Saturn, Modern: Uranus
    "Pis": "Jupiter" # Traditional: Jupiter, Modern: Neptune
}

# --- Zodiac Signs Order ---
SIGNS = ["Ari", "Tau", "Gem", "Can", "Leo", "Vir", "Lib", "Sco", "Sag", "Cap", "Aqu", "Pis"]
SIGN_START_LONGITUDES = { sign: i * 30.0 for i, sign in enumerate(SIGNS) }

# --- Varga Calculation Constants ---
# D3 - Drekkana
D3_SPAN = 10.0 # 30 / 3
# D7 - Saptamsa
D7_SPAN = 30.0 / 7.0 # Approximately 4.2857 degrees
# D9 - Navamsa
NAVAMSA_SPAN = 30.0 / 9.0 # 3 degrees 20 minutes
NAVAMSA_START_INDICES = { # Counting starts from Movable(1), Fixed(9), Dual(5) -> simplified to indices 0, 8, 4? Let's stick to classic
    "Ari": 0, "Leo": 0, "Sag": 0, # Movable starts from 1st (Aries)
    "Tau": 8, "Vir": 8, "Cap": 8, # Fixed starts from 9th (Sagittarius) - ERROR in original D9 comment, should be Cap index 9
    "Gem": 4, "Lib": 4, "Aqu": 4, # Dual starts from 5th (Leo) - ERROR in original D9 comment, should be Gem index 4
    "Can": 0, "Sco": 8, "Pis": 4  # Movable, Fixed, Dual respectively
}
# D10 - Dasamsa
D10_SPAN = 3.0 # 30 / 10
# D16 - Shodasamsa
D16_SPAN = 30.0 / 16.0 # 1.875 degrees

# --- Varga Role Labels ---
VARGA_ROLES = {
    "D3": "‚ö° Momentum Initiator",
    "D7": "üìà Growth & Expansion",
    "D9": "ü§ù Relationship & Dharma", # Added for consistency
    "D10": "üèõÔ∏è Institutional Power",
    "D16": "üåä Technical Flow & Volatility"
}


# --- House Attribute Mapping (for getting cusp signs) ---
HOUSE_NUM_TO_ATTR = {
    1: 'first_house', 2: 'second_house', 3: 'third_house',
    4: 'fourth_house', 5: 'fifth_house', 6: 'sixth_house',
    7: 'seventh_house', 8: 'eighth_house', 9: 'ninth_house',
    10: 'tenth_house', 11: 'eleventh_house', 12: 'twelfth_house'
}

# --- Configuration (Combined) ---
natal_name = "S&P500"; natal_year = 1957; natal_month = 3; natal_day = 4; natal_hour_local = 9; natal_minute_local = 30
transit_name = "Transit Chart (Mar 28, 2025)"; transit_year = 2025; transit_month = 3; transit_day = 28; transit_hour_local = 9; transit_minute_local = 30

location_city = "New York"; location_nation = "US"; location_latitude = 40.7128; location_longitude = -74.0060; location_timezone_str = "America/New_York"
ayanamsa = "LAHIRI"; house_system_identifier = "S"; zodiac_type = "Sidereal"
house_system_names = { "P": "Placidus", "K": "Koch", "R": "Regiomontanus", "C": "Campanus", "E": "Equal", "W": "Whole Sign", "X": "Axial Rotation System", "H": "Horizontal System", "T": "Polich/Page (Topocentric)", "B": "Alcabitus", "M": "Morinus", "U": "Krusinski-Pisa-Goelzer", "S": "Sripathi" }
house_system_name = house_system_names.get(house_system_identifier, f"Unknown ({house_system_identifier})")
KERYKEION_ONLINE_MODE = False

# --- Aspect Configuration ---
ASPECTS_TO_CHECK = [0, 60, 90, 120, 180]
ASPECT_NAMES = { 0: "Conjunct", 60: "Sextile", 90: "Square", 120: "Trine", 180: "Opposite"}
MAX_ASPECT_ORB = 5.0
MAX_TRANSIT_ASPECT_ORB = 3.0
STATIONARY_SPEED_THRESHOLD = 1e-6

# --- Planet/Point Configuration ---
EXPECTED_BODIES_FOR_SPEED = [
    'sun', 'moon', 'mercury', 'venus', 'mars', 'jupiter', 'saturn',
    'uranus', 'neptune', 'pluto', 'mean_node', 'true_node', 'true_south_node'
]
PLANETS_FOR_SPEED_TABLE = [
    "Sun", "Moon", "Mercury", "Venus", "Mars", "Jupiter", "Saturn",
    "Uranus", "Neptune", "Pluto", "True Node", "True S. Node"
]
PLANETS_FOR_ASPECTS = [
    "Sun", "Moon", "Mercury", "Venus", "Mars", "Jupiter",
    "Saturn", "Uranus", "Neptune", "Pluto", "Ascendant",
    "True Node"
]
PLANETS_FOR_TRANSIT_ASPECTS = [
    "Sun", "Moon", "Mercury", "Venus", "Mars", "Jupiter",
    "Saturn", "Uranus", "Neptune", "Pluto",
    "True Node",
]
POINTS_FOR_DIVISIONAL_CHARTS = [
    ("Ascendant", "ascendant"), ("MC", "mc"), ("Sun", "sun"), ("Moon", "moon"),
    ("Mercury", "mercury"), ("Venus", "venus"), ("Mars", "mars"), ("Jupiter", "jupiter"),
    ("Saturn", "saturn"), ("Uranus", "uranus"), ("Neptune", "neptune"), ("Pluto", "pluto"),
    ("True Node", "true_node"), ("True S. Node", "true_south_node"),
]

PLANET_ATTRIBUTE_MAP = {
    'sun': 'Sun', 'moon': 'Moon', 'mercury': 'Mercury', 'venus': 'Venus',
    'mars': 'Mars', 'jupiter': 'Jupiter', 'saturn': 'Saturn', 'uranus': 'Uranus',
    'neptune': 'Neptune', 'pluto': 'Pluto', 'mean_node': 'Mean_Node',
    'true_node': 'True Node', 'chiron': 'Chiron', 'mean_lilith': 'Mean_Lilith',
    'ascendant': 'Ascendant', 'mc': 'MC', 'medium_coeli': 'MC',
    'first_house': 'Ascendant', 'tenth_house': 'MC', 'true_south_node': 'True S. Node'
}
ATTRIBUTE_PLANET_MAP = {v: k for k, v in PLANET_ATTRIBUTE_MAP.items()}

# --- Timezone Helper Function ---
def get_utc_datetime(year, month, day, hour, minute, tz_str):
    """Converts local time to UTC using zoneinfo or pytz."""
    if _use_zoneinfo:
        try: local_tz = ZoneInfo(tz_str); local_dt = datetime(year, month, day, hour, minute, tzinfo=local_tz); utc_dt = local_dt.astimezone(timezone.utc); return utc_dt
        except ZoneInfoNotFoundError: print(f"Error: Timezone '{tz_str}' not found by zoneinfo."); return None
        except Exception as e_zi: print(f"Error: zoneinfo error for {year}-{month}-{day} {hour}:{minute} in {tz_str}: {e_zi}"); return None
    elif _use_pytz:
        try: local_tz = pytz.timezone(tz_str); local_dt = datetime(year, month, day, hour, minute); local_dt_aware = local_tz.localize(local_dt, is_dst=None); utc_dt = local_dt_aware.astimezone(pytz.utc); return utc_dt
        except pytz.exceptions.UnknownTimeZoneError: print(f"Error: Timezone '{tz_str}' not found by pytz."); return None
        except pytz.exceptions.AmbiguousTimeError: print(f"Error: Ambiguous time encountered for {year}-{month}-{day} {hour}:{minute} in {tz_str}. Try adjusting the time slightly."); return None
        except pytz.exceptions.NonExistentTimeError: print(f"Error: Non-existent time encountered for {year}-{month}-{day} {hour}:{minute} in {tz_str} (likely during DST spring-forward). Try adjusting the time."); return None
        except Exception as e_pytz: print(f"Error: pytz error for {year}-{month}-{day} {hour}:{minute} in {tz_str}: {e_pytz}"); return None
    else: print("Error: Neither zoneinfo nor pytz is available for timezone handling."); return None

# --- NAKSHATRA DATA AND FUNCTIONS ---
NAKSHATRA_BOUNDARIES = [
    {"Name": "Ashwini", "Start": 0.0, "End": 13.3333, "Ruler": "Ketu"}, {"Name": "Bharani", "Start": 13.3333, "End": 26.6667, "Ruler": "Venus"}, {"Name": "Krittika", "Start": 26.6667, "End": 40.0, "Ruler": "Sun"},
    {"Name": "Rohini", "Start": 40.0, "End": 53.3333, "Ruler": "Moon"}, {"Name": "Mrigashira", "Start": 53.3333, "End": 66.6667, "Ruler": "Mars"}, {"Name": "Ardra", "Start": 66.6667, "End": 80.0, "Ruler": "Rahu"},
    {"Name": "Punarvasu", "Start": 80.0, "End": 93.3333, "Ruler": "Jupiter"}, {"Name": "Pushya", "Start": 93.3333, "End": 106.6667, "Ruler": "Saturn"}, {"Name": "Ashlesha", "Start": 106.6667, "End": 120.0, "Ruler": "Mercury"},
    {"Name": "Magha", "Start": 120.0, "End": 133.3333, "Ruler": "Ketu"}, {"Name": "Purva Phalguni", "Start": 133.3333, "End": 146.6667, "Ruler": "Venus"}, {"Name": "Uttara Phalguni", "Start": 146.6667, "End": 160.0, "Ruler": "Sun"},
    {"Name": "Hasta", "Start": 160.0, "End": 173.3333, "Ruler": "Moon"}, {"Name": "Chitra", "Start": 173.3333, "End": 186.6667, "Ruler": "Mars"}, {"Name": "Swati", "Start": 186.6667, "End": 200.0, "Ruler": "Rahu"},
    {"Name": "Vishakha", "Start": 200.0, "End": 213.3333, "Ruler": "Jupiter"}, {"Name": "Anuradha", "Start": 213.3333, "End": 226.6667, "Ruler": "Saturn"}, {"Name": "Jyeshtha", "Start": 226.6667, "End": 240.0, "Ruler": "Mercury"},
    {"Name": "Mula", "Start": 240.0, "End": 253.3333, "Ruler": "Ketu"}, {"Name": "Purva Ashadha", "Start": 253.3333, "End": 266.6667, "Ruler": "Venus"}, {"Name": "Uttara Ashadha", "Start": 266.6667, "End": 280.0, "Ruler": "Sun"},
    {"Name": "Shravana", "Start": 280.0, "End": 293.3333, "Ruler": "Moon"}, {"Name": "Dhanishtha", "Start": 293.3333, "End": 306.6667, "Ruler": "Mars"}, {"Name": "Shatabhisha", "Start": 306.6667, "End": 320.0, "Ruler": "Rahu"},
    {"Name": "Purva Bhadrapada", "Start": 320.0, "End": 333.3333, "Ruler": "Jupiter"}, {"Name": "Uttara Bhadrapada", "Start": 333.3333, "End": 346.6667, "Ruler": "Saturn"}, {"Name": "Revati", "Start": 346.6667, "End": 360.0, "Ruler": "Mercury"}
]
STANDARD_NAKSHATRA_SPAN = 360.0 / 27.0
STANDARD_PADA_SPAN = STANDARD_NAKSHATRA_SPAN / 4.0

def calculate_nakshatra_from_boundaries(absolute_longitude):
    """Calculates Nakshatra name, pada, and ruler from absolute longitude using custom boundaries."""
    if not NAKSHATRA_BOUNDARIES: return {"name": "Data Missing", "pada": "N/A", "ruler": "N/A"}
    if absolute_longitude is None or not isinstance(absolute_longitude, (int, float)): return {"name": "Invalid Lon", "pada": "N/A", "ruler": "N/A"}
    epsilon = 1e-9; longitude_norm = (absolute_longitude + epsilon) % 360.0
    if longitude_norm < epsilon: longitude_norm = 360.0 - epsilon # Treat near-zero as near-360 for boundary check consistency

    for nak_info in NAKSHATRA_BOUNDARIES:
        nak_start = nak_info["Start"]; nak_end = nak_info["End"]
        # Adjust end slightly for consistent < check, especially for 360.0
        effective_end = nak_end + epsilon if nak_end != 360.0 else 360.0 + epsilon

        if nak_start < effective_end: # Normal case (e.g., 0 to 13.33)
            if nak_start <= longitude_norm < effective_end:
                degrees_into_nakshatra = longitude_norm - nak_start
                pada_calc = (degrees_into_nakshatra + epsilon) / STANDARD_PADA_SPAN
                pada = int(math.floor(pada_calc)) + 1; pada = max(1, min(4, pada))
                return {"name": nak_info["Name"], "pada": pada, "ruler": nak_info["Ruler"]}
        else: # Wrap-around case (e.g., Krittika ending at 40, starts at 26.6; Revati ending at 360, starts 346)
             if longitude_norm >= nak_start or longitude_norm < nak_end : # nak_end is 360 here, this condition works
                degrees_into_nakshatra = (longitude_norm - nak_start + 360) % 360
                pada_calc = (degrees_into_nakshatra + epsilon) / STANDARD_PADA_SPAN
                pada = int(math.floor(pada_calc)) + 1; pada = max(1, min(4, pada))
                return {"name": nak_info["Name"], "pada": pada, "ruler": nak_info["Ruler"]}

    # Fallback check for the very last point near 360
    last_nak = NAKSHATRA_BOUNDARIES[-1]
    if last_nak["Start"] <= longitude_norm <= last_nak["End"] + epsilon : # Check near 360
        degrees_into_nakshatra = longitude_norm - last_nak["Start"]
        pada_calc = (degrees_into_nakshatra + epsilon) / STANDARD_PADA_SPAN
        pada = int(math.floor(pada_calc)) + 1; pada = max(1, min(4, pada))
        return {"name": last_nak["Name"], "pada": pada, "ruler": last_nak["Ruler"]}

    print(f"Debug: Nakshatra not found for longitude {absolute_longitude} (norm: {longitude_norm})")
    return {"name": "Not Found", "pada": "N/A", "ruler": "N/A"}

def print_nakshatras(subject: AstrologicalSubject, chart_type: str):
    """Prints Nakshatra details for key points in a chart."""
    if not subject: print(f"Cannot print Nakshatras for {chart_type}, subject is None."); return
    print(f"\n--- {chart_type} Nakshatra Positions ---")
    for point_name, attr_name in POINTS_FOR_DIVISIONAL_CHARTS:
        nak_name, nak_pada, nak_lord = "N/A", "N/A", "N/A"; rasi_sign, pos_in_sign_str, retrograde = "N/A", "N/A", ""; output_str = f"{point_name:<12}: Point data unavailable."
        try:
            point_obj = getattr(subject, attr_name, None)
            absolute_longitude = None
            pos_in_sign = None

            if point_obj and hasattr(point_obj, 'sign') and hasattr(point_obj, 'position'):
                rasi_sign = getattr(point_obj, 'sign', 'N/A')
                pos_in_sign = getattr(point_obj, 'position', None)
                pos_in_sign_str = f"{pos_in_sign:.2f}" if pos_in_sign is not None else "N/A"

            if point_obj and hasattr(point_obj, 'sign_pos') and getattr(point_obj, 'sign_pos', None) is not None:
                absolute_longitude = point_obj.sign_pos
            elif rasi_sign != 'N/A' and pos_in_sign is not None:
                sign_start_lon = SIGN_START_LONGITUDES.get(rasi_sign)
                if sign_start_lon is not None:
                    absolute_longitude = (sign_start_lon + pos_in_sign) % 360.0

            retrograde = " (R)" if hasattr(point_obj, 'retrograde') and getattr(point_obj, 'retrograde', False) else ""

            if absolute_longitude is not None:
                nak_info = calculate_nakshatra_from_boundaries(absolute_longitude)
                nak_name = nak_info.get('name', 'Calc Error')
                nak_pada = nak_info.get('pada', 'N/A')
                nak_lord = nak_info.get('ruler', 'N/A')
                output_str = f"{point_name:<12}: {nak_name:<15} (Pada {nak_pada}, Lord: {nak_lord:<8}) [{rasi_sign} {pos_in_sign_str}¬∞{retrograde}]"
            elif point_obj:
                output_str = f"{point_name:<12}: Position/Sign data insufficient [{rasi_sign} {pos_in_sign_str}¬∞{retrograde}]"

        except Exception as e: print(f"Error processing Nakshatra for {point_name} ({attr_name}): {e}"); output_str=f"{point_name:<12}: Error processing Nakshatra."
        print(output_str)
    print("-" * 75)

# --- Helper: Get Absolute Longitude ---
def _get_absolute_longitude(point_obj):
    """Helper to retrieve or calculate absolute longitude."""
    if not point_obj: return None
    absolute_longitude = None
    if hasattr(point_obj, 'sign_pos') and getattr(point_obj, 'sign_pos', None) is not None:
        absolute_longitude = point_obj.sign_pos
    else:
        rasi_sign = getattr(point_obj, 'sign', None)
        pos_in_sign = getattr(point_obj, 'position', None)
        if rasi_sign and pos_in_sign is not None:
            sign_start_lon = SIGN_START_LONGITUDES.get(rasi_sign)
            if sign_start_lon is not None:
                absolute_longitude = (sign_start_lon + pos_in_sign) % 360.0
    return absolute_longitude

# --- Varga Calculation Functions ---

def _calculate_varga_base(absolute_longitude, varga_span, num_divisions):
    """Common base calculation logic for vargas."""
    if absolute_longitude is None or not isinstance(absolute_longitude, (int, float)):
        return None, None, None
    if not (0 <= absolute_longitude <= 360):
        absolute_longitude = absolute_longitude % 360.0
    epsilon = 1e-9
    if abs(absolute_longitude - 360.0) < epsilon: absolute_longitude = 360.0 - epsilon
    elif abs(absolute_longitude - 0.0) < epsilon: absolute_longitude = epsilon

    rasi_sign_index = math.floor(absolute_longitude / 30.0)
    rasi_sign_index = min(rasi_sign_index, 11)
    degrees_into_sign = absolute_longitude % 30.0
    if abs(degrees_into_sign - 30.0) < epsilon:
         degrees_into_sign = 30.0 - epsilon # Ensure it stays within the sign

    division_index = math.floor(degrees_into_sign / varga_span)
    division_index = max(0, min(num_divisions - 1, division_index)) # Index 0 to N-1

    return rasi_sign_index, degrees_into_sign, division_index

def calculate_drekkana(absolute_longitude):
    """Calculates the Drekkana (D3) sign and pada (division number 1-3)."""
    rasi_sign_index, _, division_index = _calculate_varga_base(absolute_longitude, D3_SPAN, 3)
    if rasi_sign_index is None: return None

    # D3 rule: 1st drekkana -> same sign, 2nd -> 5th sign, 3rd -> 9th sign
    offset = 0
    if division_index == 1: offset = 4 # 5th sign is index + 4
    elif division_index == 2: offset = 8 # 9th sign is index + 8

    final_varga_index = (rasi_sign_index + offset) % 12
    varga_sign = SIGNS[final_varga_index]
    pada = division_index + 1 # Pada is 1, 2, or 3
    return {"varga_sign": varga_sign, "varga_pada": pada}

def calculate_saptamsa(absolute_longitude):
    """Calculates the Saptamsa (D7) sign and pada (division number 1-7)."""
    rasi_sign_index, _, division_index = _calculate_varga_base(absolute_longitude, D7_SPAN, 7)
    if rasi_sign_index is None: return None

    # D7 rule: Odd signs count from self, Even signs count from 7th
    is_odd_sign = (rasi_sign_index % 2 == 0) # Aries=0 (odd), Tau=1 (even)

    if is_odd_sign:
        start_index = rasi_sign_index
    else:
        start_index = (rasi_sign_index + 6) % 12 # 7th sign is index + 6

    final_varga_index = (start_index + division_index) % 12
    varga_sign = SIGNS[final_varga_index]
    pada = division_index + 1 # Pada is 1 to 7
    return {"varga_sign": varga_sign, "varga_pada": pada}

def calculate_navamsa(absolute_longitude):
    """Calculates the Navamsa (D9) sign and pada (division number 1-9)."""
    # This uses slightly different logic with precomputed start indices
    if absolute_longitude is None or not isinstance(absolute_longitude, (int, float)): return None
    if not (0 <= absolute_longitude <= 360): absolute_longitude = absolute_longitude % 360.0
    epsilon = 1e-9
    if abs(absolute_longitude - 360.0) < epsilon: absolute_longitude = 360.0 - epsilon
    elif abs(absolute_longitude - 0.0) < epsilon: absolute_longitude = epsilon

    rasi_sign_index = math.floor(absolute_longitude / 30.0)
    rasi_sign_index = min(rasi_sign_index, 11)
    rasi_sign = SIGNS[rasi_sign_index]
    degrees_into_sign = absolute_longitude % 30.0
    if abs(degrees_into_sign - 30.0) < epsilon:
         degrees_into_sign = 30.0 - epsilon

    navamsa_index_in_sign = math.floor(degrees_into_sign / NAVAMSA_SPAN) # This is the 'pada' index 0-8
    navamsa_index_in_sign = max(0, min(8, navamsa_index_in_sign))
    navamsa_pada = navamsa_index_in_sign + 1 # Make it 1-9

    # Determine start sign based on Movable/Fixed/Dual nature
    modality_group = rasi_sign_index % 3 # 0=Movable, 1=Fixed, 2=Dual
    if modality_group == 0: # Movable (Ari, Can, Lib, Cap) -> Start Aries (0)
        start_navamsa_index = 0
    elif modality_group == 1: # Fixed (Tau, Leo, Sco, Aqu) -> Start Sagittarius (8) - Corrected Rule
        start_navamsa_index = 8
    else: # Dual (Gem, Vir, Sag, Pis) -> Start Leo (4) - Corrected Rule
        start_navamsa_index = 4

    final_navamsa_index = (start_navamsa_index + navamsa_index_in_sign) % 12
    navamsa_sign = SIGNS[final_navamsa_index]
    return {"varga_sign": navamsa_sign, "varga_pada": navamsa_pada}


def calculate_dasamsa(absolute_longitude):
    """Calculates the Dasamsa (D10) sign and pada (division number 1-10)."""
    rasi_sign_index, _, division_index = _calculate_varga_base(absolute_longitude, D10_SPAN, 10)
    if rasi_sign_index is None: return None

    # D10 rule: Odd signs count from self, Even signs count from 9th
    is_odd_sign = (rasi_sign_index % 2 == 0) # Aries=0 (odd), Tau=1 (even)

    if is_odd_sign:
        start_index = rasi_sign_index
    else:
        start_index = (rasi_sign_index + 8) % 12 # 9th sign is index + 8

    final_varga_index = (start_index + division_index) % 12
    varga_sign = SIGNS[final_varga_index]
    pada = division_index + 1 # Pada is 1 to 10
    return {"varga_sign": varga_sign, "varga_pada": pada}

def calculate_shodasamsa(absolute_longitude):
    """Calculates the Shodasamsa (D16) sign and pada (division number 1-16)."""
    rasi_sign_index, _, division_index = _calculate_varga_base(absolute_longitude, D16_SPAN, 16)
    if rasi_sign_index is None: return None

    # D16 rule: Movable starts Aries(0), Fixed starts Leo(4), Dual starts Sagittarius(8)
    modality_group = rasi_sign_index % 3 # 0=Movable, 1=Fixed, 2=Dual

    if modality_group == 0: # Movable (Ari, Can, Lib, Cap)
        start_index = 0
    elif modality_group == 1: # Fixed (Tau, Leo, Sco, Aqu)
        start_index = 4
    else: # Dual (Gem, Vir, Sag, Pis)
        start_index = 8

    final_varga_index = (start_index + division_index) % 12
    varga_sign = SIGNS[final_varga_index]
    pada = division_index + 1 # Pada is 1 to 16
    return {"varga_sign": varga_sign, "varga_pada": pada}


# --- UPDATED Helper Function to Determine Rasi House ---
def get_rasi_house_number(subject: AstrologicalSubject, absolute_longitude: float, chart_type_for_debug: str = "") -> int | None:
    """
    Determines the house number (1-12) a given absolute longitude falls into,
    based on the subject's calculated house cusps.
    Attempts to calculate cusp sign_pos if missing from Kerykeion object.

    Args:
        subject: The AstrologicalSubject object containing house cusp data.
        absolute_longitude: The absolute longitude of the point to check (0 <= lon < 360).
        chart_type_for_debug: Optional string (e.g., "Natal") for debug messages.

    Returns:
        The house number (1-12) or None if cusps are missing or calculation fails.
    """
    if absolute_longitude is None:
        # print(f"Debug ({chart_type_for_debug} get_rasi_house_number): Input longitude is None.")
        return None

    cusp_positions = []
    missing_cusp_data = False
    # print(f"--- Debug ({chart_type_for_debug}): Retrieving Cusp Positions ---") # Optional Debug Grouping
    try:
        for i in range(1, 13):
            house_attr = HOUSE_NUM_TO_ATTR.get(i)
            cusp_obj = getattr(subject, house_attr, None)
            cusp_sign_pos = None # The absolute longitude we need

            if cusp_obj:
                # Attempt 1: Get sign_pos directly (preferred)
                cusp_sign_pos = getattr(cusp_obj, 'sign_pos', None)

                # Attempt 2: Calculate if sign_pos is missing but sign/position exist (WORKAROUND)
                if cusp_sign_pos is None:
                    cusp_sign = getattr(cusp_obj, 'sign', None)
                    cusp_pos = getattr(cusp_obj, 'position', None)
                    if cusp_sign and cusp_pos is not None:
                        sign_start_lon = SIGN_START_LONGITUDES.get(cusp_sign)
                        if sign_start_lon is not None:
                            cusp_sign_pos = (sign_start_lon + cusp_pos) % 360.0
                            # print(f"  Debug ({chart_type_for_debug}): House {i} - Manually calculated cusp sign_pos: {cusp_sign_pos:.4f} (from {cusp_sign} {cusp_pos:.2f})") # DEBUG Workaround
                        # else: print(f"  Debug ({chart_type_for_debug}): House {i} - Found sign/pos but couldn't get sign start longitude for {cusp_sign}")
                    # else: print(f"  Debug ({chart_type_for_debug}): House {i} - sign_pos missing, also missing sign ({cusp_sign}) or position ({cusp_pos})")
                # else: print(f"  Debug ({chart_type_for_debug}): House {i} - Found sign_pos directly: {cusp_sign_pos:.4f}") # DEBUG Success

            # Check if we successfully got or calculated a valid sign_pos for this cusp
            if cusp_sign_pos is None:
                print(f"Warning ({chart_type_for_debug} get_rasi_house_number): Failed to get or calculate valid sign_pos for house {i}. Cannot determine house placements.")
                missing_cusp_data = True
                break # Exit loop early, cannot proceed

            cusp_positions.append(cusp_sign_pos)

    except Exception as e:
        print(f"Error ({chart_type_for_debug} get_rasi_house_number): Exception while retrieving/calculating cusp positions: {e}")
        traceback.print_exc(limit=1)
        return None # Error during retrieval

    # If loop finished because of missing data, return None
    if missing_cusp_data:
        return None

    # Check if we have exactly 12 positions after the loop
    if len(cusp_positions) != 12:
        print(f"Warning ({chart_type_for_debug} get_rasi_house_number): Expected 12 cusp positions, found {len(cusp_positions)}. House calculation failed.")
        return None

    # --- Now proceed with the house placement logic using cusp_positions ---
    epsilon = 1e-9
    longitude_norm = absolute_longitude % 360.0
    if longitude_norm < 0: longitude_norm += 360.0
    if abs(longitude_norm - 360.0) < epsilon: longitude_norm = 360.0 - epsilon
    if abs(longitude_norm - 0.0) < epsilon: longitude_norm = epsilon

    # cusp_strs_debug = [f"{i+1}:{p:.3f}" for i, p in enumerate(cusp_positions)]
    # print(f"Debug ({chart_type_for_debug} get_rasi_house_number): Checking lon {longitude_norm:.4f} against calculated cusps: {', '.join(cusp_strs_debug)}")

    for i in range(12):
        house_num = i + 1
        start_cusp_lon = cusp_positions[i] # Already normalized 0-360
        end_cusp_idx = (i + 1) % 12
        end_cusp_lon = cusp_positions[end_cusp_idx] # Already normalized 0-360

        # Adjust near-zero values for comparison consistency
        start_compare = start_cusp_lon
        end_compare = end_cusp_lon
        if abs(start_compare) < epsilon: start_compare = 0.0
        if abs(end_compare) < epsilon: end_compare = 0.0 # If end cusp is 0 Aries

        # print(f"  House {house_num}: Start {start_compare:.3f}, End {end_compare:.3f}") # Optional Debug

        # Check if the house range wraps around 0/360 degrees
        if end_compare < start_compare: # Wrap-around case (e.g., start=340, end=10 or end=0)
             # In this house if (longitude >= start) OR (longitude < end)
             # Example: Start 330, End 10. Lon 345 -> True. Lon 5 -> True. Lon 20 -> False.
             # Example: Start 330, End 0. Lon 345 -> True. Lon 359.9 -> True. Lon 0.001 -> False (should be next house)
             if longitude_norm >= start_compare or longitude_norm < end_compare:
                 # print(f"    -> Found in House {house_num} (Wrap)")
                 return house_num
        else: # Normal case (e.g., start=10, end=40)
            # Longitude must be >= start AND < end
            # Example: Start 10, End 40. Lon 10 -> True. Lon 39.9 -> True. Lon 40 -> False.
            # Example: Start 0, End 30. Lon 0.001 -> True. Lon 29.9 -> True. Lon 30 -> False.
            if longitude_norm >= start_compare and longitude_norm < end_compare:
                 # print(f"    -> Found in House {house_num} (Normal)")
                 return house_num

    # Fallback if no house found
    print(f"Warning ({chart_type_for_debug} get_rasi_house_number): Could not place longitude {absolute_longitude:.4f} (norm: {longitude_norm:.4f}) into any house range.")
    cusp_strs = [f"{p:.2f}" for p in cusp_positions]
    print(f"Debug: Cusps used for check: {', '.join(cusp_strs)}")
    return None


# --- Generic Varga Chart Printing Function ---
def print_varga_chart(subject: AstrologicalSubject, chart_type: str, varga_name: str, varga_num: int, calculation_function: callable, role_label: str):
    """
    Generic function to print Varga (Divisional) charts (D3, D7, D9, D10, D16).
    Prints positions including Rasi House (calculated), Lord, Dignity, Varga Sign, and Pada.
    Dignity refers to the Rasi position.
    Relies on get_rasi_house_number to handle cusp data availability.
    """
    if not subject:
        print(f"Cannot print {varga_name} chart for {chart_type}, subject is None.")
        return

    print(f"\n--- {chart_type.upper()} {varga_name.upper()} (D{varga_num}) CHART: {role_label} ---")
    print(f"{'Point':<12} {'Rasi Sign':<10} {'House':<6} {'Lord':<10} {'Dignity':<14} {'Varga Sign':<14} {'Pada':<5}")
    print("-" * 80) # Adjusted width

    for point_name, attr_name in POINTS_FOR_DIVISIONAL_CHARTS:
        rasi_sign, varga_sign, varga_pada = "N/A", "N/A", "N/A"
        house_num_int = None
        house_num_str = "N/A" # Default
        house_lord, dignity = "N/A", "N/A"
        retrograde = ""
        output_str = f"{point_name:<12}: Data unavailable"

        try:
            point_obj = getattr(subject, attr_name, None)
            absolute_longitude = None
            pos_in_sign = None # Position within the Rasi sign (0-30)

            if point_obj:
                # --- Get Rasi Details & Absolute Longitude ---
                rasi_sign = getattr(point_obj, 'sign', 'N/A')
                pos_in_sign = getattr(point_obj, 'position', None)
                retrograde = " (R)" if hasattr(point_obj, 'retrograde') and getattr(point_obj, 'retrograde', False) else ""

                absolute_longitude = _get_absolute_longitude(point_obj)

                # --- Calculate Rasi House Number (using the UPDATED helper) ---
                if absolute_longitude is not None:
                    # Pass chart type for clearer debug messages inside the helper
                    house_num_int = get_rasi_house_number(subject, absolute_longitude, chart_type)
                    if house_num_int is not None:
                        house_num_str = str(house_num_int)
                    else:
                        # get_rasi_house_number returned None, meaning cusps were missing/invalid
                        # or longitude couldn't be placed. The function itself should have printed a warning.
                        house_num_str = "NoCusps" # Assume cusp failure if None returned
                else: # Longitude missing for the point
                    house_num_str = "NoLon"

                # --- Get Rasi House Lord (uses house_num_int) ---
                if house_num_int is not None: # Only if house calculation was successful
                    house_attr_lord_lookup = HOUSE_NUM_TO_ATTR.get(house_num_int)
                    if house_attr_lord_lookup:
                        try:
                            # Lord is determined by the SIGN ON THE CUSP of the house the planet is IN
                            cusp_obj_lord_lookup = getattr(subject, house_attr_lord_lookup, None)
                            if cusp_obj_lord_lookup and hasattr(cusp_obj_lord_lookup, 'sign'):
                                cusp_sign_lord = cusp_obj_lord_lookup.sign # Get the sign ON THE CUSP
                                house_lord = ZODIAC_RULERS.get(cusp_sign_lord, "Unknown")
                            else: house_lord = "Cusp Sign?"
                        except Exception as e_lord: house_lord = "Lord Err"
                    else: house_lord = "Attr Err"
                # else house_lord remains 'N/A' if house_num_int is None

                # --- Get Rasi Dignity ---
                if point_name in ["Ascendant", "MC"] or "Node" in point_name:
                    dignity = "N/A"
                else:
                    try:
                        dignity_raw = getattr(point_obj, 'dignity', None)
                        dignity = dignity_raw.replace("_", " ").title() if dignity_raw else "None"
                    except AttributeError: dignity = "N/A"

                # --- Calculate Varga ---
                if absolute_longitude is not None:
                    varga_info = calculation_function(absolute_longitude)
                    if varga_info:
                        varga_sign = varga_info.get('varga_sign', 'Calc Err')
                        varga_pada = varga_info.get('varga_pada', 'N/A')
                    else: varga_sign, varga_pada = 'Calc Err', 'N/A'
                else: varga_sign, varga_pada = 'NoLon', 'N/A'

                # --- Format Output String ---
                output_str = (f"{point_name:<12} {rasi_sign:<10} {house_num_str:<6} "
                              f"{house_lord:<10} {dignity:<14} {varga_sign:<14} "
                              f"{str(varga_pada):<5} {retrograde}")

            # else: output_str remains "Data unavailable" if point_obj is None

        except Exception as e:
            print(f"Error processing {varga_name} row for {point_name} ({attr_name}) in {chart_type}: {e}")
            traceback.print_exc(limit=1)
            output_str = f"{point_name:<12} {'Error':<10} {'Err':<6} {'Error':<10} {'Error':<14} {'Error':<14} {'Err':<5}"
        print(output_str)
    print("-" * 80) # Adjusted width


# --- Specific Varga Print Functions (using the generic template) ---

def print_drekkana_chart(subject: AstrologicalSubject, chart_type: str):
    print_varga_chart(subject, chart_type, "Drekkana", 3, calculate_drekkana, VARGA_ROLES["D3"])

def print_saptamsa_chart(subject: AstrologicalSubject, chart_type: str):
    print_varga_chart(subject, chart_type, "Saptamsa", 7, calculate_saptamsa, VARGA_ROLES["D7"])

def print_navamsa_chart(subject: AstrologicalSubject, chart_type: str):
    # Use the corrected Navamsa calculation function
    print_varga_chart(subject, chart_type, "Navamsa", 9, calculate_navamsa, VARGA_ROLES["D9"])

def print_dasamsa_chart(subject: AstrologicalSubject, chart_type: str):
    print_varga_chart(subject, chart_type, "Dasamsa", 10, calculate_dasamsa, VARGA_ROLES["D10"])

def print_shodasamsa_chart(subject: AstrologicalSubject, chart_type: str):
    print_varga_chart(subject, chart_type, "Shodasamsa", 16, calculate_shodasamsa, VARGA_ROLES["D16"])

# --- Wrapper Function to Print All Divisional Charts ---
def print_all_divisional_charts(subject: AstrologicalSubject, chart_type: str):
    """Prints D3, D7, D9, D10, and D16 charts for the given subject and type."""
    if not subject:
        print(f"Cannot print divisional charts for {chart_type}, subject is None.")
        return

    print(f"\n{'='*20} ALL DIVISIONAL CHARTS: {chart_type.upper()} {'='*20}")

    try:
        print_drekkana_chart(subject, chart_type)
    except Exception as e:
        print(f"\nError printing {chart_type} Drekkana (D3) Chart: {e}")
        traceback.print_exc(limit=1)

    try:
        print_saptamsa_chart(subject, chart_type)
    except Exception as e:
        print(f"\nError printing {chart_type} Saptamsa (D7) Chart: {e}")
        traceback.print_exc(limit=1)

    try:
        print_navamsa_chart(subject, chart_type) # Uses the generic printer now
    except Exception as e:
        print(f"\nError printing {chart_type} Navamsa (D9) Chart: {e}")
        traceback.print_exc(limit=1)

    try:
        print_dasamsa_chart(subject, chart_type)
    except Exception as e:
        print(f"\nError printing {chart_type} Dasamsa (D10) Chart: {e}")
        traceback.print_exc(limit=1)

    try:
        print_shodasamsa_chart(subject, chart_type)
    except Exception as e:
        print(f"\nError printing {chart_type} Shodasamsa (D16) Chart: {e}")
        traceback.print_exc(limit=1)

    print(f"\n{'='*20} END DIVISIONAL CHARTS: {chart_type.upper()} {'='*20}")


# --- CUSTOM SPEED CALCULATION FUNCTION ---
# [No changes needed here]
def calculate_custom_speeds(subject_t0: AstrologicalSubject):
    """Calculates daily speed (deg/day) for planets by comparing t0 and t0+1day."""
    if not subject_t0: print("ERROR (calculate_custom_speeds): Input subject_t0 is None."); return None
    try:
        planets_t0 = {};
        for attr_name in EXPECTED_BODIES_FOR_SPEED:
            if hasattr(subject_t0, attr_name):
                planet_obj = getattr(subject_t0, attr_name); dict_key = PLANET_ATTRIBUTE_MAP.get(attr_name, attr_name)
                if not dict_key: continue
                abs_lon = _get_absolute_longitude(planet_obj) # Use helper
                if abs_lon is not None: planets_t0[dict_key] = {'lon': abs_lon}

        if not planets_t0: print("ERROR (calculate_custom_speeds): Failed to retrieve any valid planet longitude for t0."); return None

        if not all(hasattr(subject_t0, attr) for attr in ['year', 'month', 'day', 'hour', 'minute']): print("ERROR (calculate_custom_speeds): subject_t0 missing time attributes."); return None
        if not all(isinstance(getattr(subject_t0, attr), int) for attr in ['year', 'month', 'day', 'hour', 'minute']): print("ERROR (calculate_custom_speeds): subject_t0 has invalid time attributes."); return None
        try: t0_dt_utc = datetime(subject_t0.year, subject_t0.month, subject_t0.day, subject_t0.hour, subject_t0.minute, 0, tzinfo=timezone.utc)
        except ValueError as ve: print(f"ERROR (calculate_custom_speeds): Invalid date/time values in subject_t0: {ve}"); return None
        t1_dt_utc = t0_dt_utc + timedelta(days=1)

        subject_t1 = AstrologicalSubject(
            name=subject_t0.name + " +1d",
            year=t1_dt_utc.year, month=t1_dt_utc.month, day=t1_dt_utc.day,
            hour=t1_dt_utc.hour, minute=t1_dt_utc.minute,
            city=getattr(subject_t0, 'city', None), nation=getattr(subject_t0, 'nation', None),
            lng=getattr(subject_t0, 'lng', None), lat=getattr(subject_t0, 'lat', None),
            tz_str=getattr(subject_t0, 'tz_str', "UTC"),
            zodiac_type=getattr(subject_t0, 'zodiac_type', 'Tropical'),
            sidereal_mode=getattr(subject_t0, 'sidereal_mode', 'LAHIRI'),
            houses_system_identifier=getattr(subject_t0, 'houses_system_identifier', 'P'),
            online=KERYKEION_ONLINE_MODE
        )

        planets_t1 = {};
        for attr_name in EXPECTED_BODIES_FOR_SPEED:
             if hasattr(subject_t1, attr_name):
                  planet_obj = getattr(subject_t1, attr_name); dict_key = PLANET_ATTRIBUTE_MAP.get(attr_name, attr_name)
                  if not dict_key: continue
                  abs_lon = _get_absolute_longitude(planet_obj) # Use helper
                  if abs_lon is not None: planets_t1[dict_key] = {'lon': abs_lon}

        if not planets_t1: print("ERROR (calculate_custom_speeds): Failed to retrieve any valid planet longitude for t1."); del subject_t1; return None

        calculated_speeds = {};
        for planet_key, p0_data in planets_t0.items():
            p1_data = planets_t1.get(planet_key)
            if not p1_data: continue
            lon0 = p0_data['lon']; lon1 = p1_data['lon']
            delta_lon = lon1 - lon0
            if delta_lon > 180.0: delta_lon -= 360.0
            elif delta_lon < -180.0: delta_lon += 360.0
            calculated_speeds[planet_key] = delta_lon

        del subject_t1
        if not calculated_speeds: print("\nERROR (calculate_custom_speeds): No speeds were calculated."); return None
        return calculated_speeds

    except Exception as e: print(f"ERROR during custom speed calculation: {e}"); traceback.print_exc(); return None

# --- HELPER FUNCTION FOR SPEED CLASSIFICATION ---
# [No changes needed here]
def get_speed_classification(planet_name, speed):
    """Provides a qualitative description of planetary speed."""
    if speed is None: return "N/A"
    abs_speed = abs(speed); is_retro = speed < -STATIONARY_SPEED_THRESHOLD
    is_stat = abs_speed <= STATIONARY_SPEED_THRESHOLD

    if is_stat: return "Stationary"
    rx_tag = " Rx" if is_retro else ""

    if planet_name == "Moon":
        if abs_speed > 14.5: return "Very Fast";
        if abs_speed > 13.5: return "Fast"
        if abs_speed > 12.0: return "Normal"
        if abs_speed > 11.0: return "Slow"
        return "Very Slow"
    elif planet_name == "Mercury":
        if abs_speed > 1.9: return "Very Fast" + rx_tag;
        if abs_speed > 1.5: return "Fast" + rx_tag;
        if abs_speed > 0.6: return "Normal" + rx_tag;
        if abs_speed > 0.1: return "Slow" + rx_tag;
        return "Very Slow" + rx_tag
    elif planet_name == "Venus":
        if abs_speed > 1.22: return "Very Fast" + rx_tag;
        if abs_speed > 1.18: return "Fast" + rx_tag;
        if abs_speed > 0.8: return "Normal" + rx_tag;
        if abs_speed > 0.1: return "Slow" + rx_tag;
        return "Very Slow" + rx_tag
    elif planet_name == "Sun": return "Normal"
    elif planet_name == "Mars":
        if abs_speed > 0.7: return "Very Fast" + rx_tag;
        if abs_speed > 0.6: return "Fast" + rx_tag;
        if abs_speed > 0.4: return "Normal" + rx_tag;
        if abs_speed > 0.15: return "Slow" + rx_tag;
        return "Very Slow" + rx_tag
    elif planet_name == "Jupiter":
        if abs_speed > 0.15: return "Fast" + rx_tag;
        if abs_speed > 0.05: return "Normal" + rx_tag;
        if abs_speed > 0.02: return "Slow" + rx_tag;
        return "Very Slow" + rx_tag
    elif planet_name == "Saturn":
        if abs_speed > 0.07: return "Fast" + rx_tag;
        if abs_speed > 0.02: return "Normal" + rx_tag;
        if abs_speed > 0.01: return "Slow" + rx_tag;
        return "Very Slow" + rx_tag
    elif planet_name == "Uranus":
        if abs_speed > 0.03: return "Normal" + rx_tag;
        if abs_speed > 0.01: return "Slow" + rx_tag;
        return "Very Slow" + rx_tag
    elif planet_name == "Neptune":
        if abs_speed > 0.02: return "Normal" + rx_tag;
        if abs_speed > 0.005: return "Slow" + rx_tag;
        return "Very Slow" + rx_tag
    elif planet_name == "Pluto":
        if abs_speed > 0.01: return "Normal" + rx_tag;
        if abs_speed > 0.002: return "Slow" + rx_tag;
        return "Very Slow" + rx_tag
    elif "Node" in planet_name:
        if speed > STATIONARY_SPEED_THRESHOLD: return "Direct"
        if abs_speed > 0.055: return "Fast Rx"
        if abs_speed > 0.045: return "Normal Rx"
        return "Slow Rx"
    else: return "N/A"

# --- FUNCTION TO PRINT PLANETARY SPEEDS with Classification ---
# [No changes needed here]
def print_planetary_speeds(speeds_dict: dict, transit_subject: AstrologicalSubject):
    """Prints a formatted table of planetary speeds and classifications."""
    if not speeds_dict: print("\nNo speeds data available to print."); return
    print("\n" + "="*30); print("      TRANSIT PLANETARY SPEEDS"); print("="*30)
    print(f"{'Planet':<12} {'Speed (¬∞/day)':<15} {'Status':<11} {'Classification':<15}")
    print("-" * 60)

    for planet_key in PLANETS_FOR_SPEED_TABLE:
        speed = speeds_dict.get(planet_key)
        speed_str = f"{speed:+.4f}" if speed is not None else "N/A"
        status_str = ""
        classification = "N/A"

        if speed is not None:
            classification = get_speed_classification(planet_key, speed)
            is_retro_by_speed = speed < -STATIONARY_SPEED_THRESHOLD
            is_stationary = abs(speed) <= STATIONARY_SPEED_THRESHOLD

            if is_stationary: status_str = "Stationary"
            elif is_retro_by_speed: status_str = "Retrograde"
            else: status_str = "Direct"

            if " Rx" in classification and status_str == "Retrograde": classification = classification.replace(" Rx", "").strip()
            if " Direct" in classification and status_str == "Direct": classification = classification.replace(" Direct", "").strip()
            if "Stationary" in classification and status_str == "Stationary": classification = classification.replace("Stationary", "").strip(); classification = classification if classification else "Stationary"
            if "Node" in planet_key and status_str == "Direct": classification = "Direct Motion"

        print(f"{planet_key:<12} {speed_str:<15} {status_str:<11} {classification:<15}")
    print("-" * 60)

# --- ASPECT CALCULATION FUNCTION (Transit-to-Natal) ---
# [No changes needed here, uses _get_absolute_longitude internally via setup]
def print_manual_transit_aspects( natal_subject: AstrologicalSubject, transit_subject: AstrologicalSubject, transit_utc_dt: datetime, aspects_list: list, max_orb: float, planets_for_aspects: list, local_tz_str: str, calculated_transit_speeds: dict ):
    """Calculates and prints aspects between transit planets and natal planets."""
    if not natal_subject or not transit_subject: print("\nCannot calculate transit-to-natal aspects: Natal or Transit subject missing."); return
    if not transit_utc_dt: print("\nCannot calculate aspect timing: Transit UTC datetime missing."); return
    if not calculated_transit_speeds: print("\nCannot calculate transit-to-natal aspects: Pre-calculated transit speeds missing."); return

    local_timezone = None
    if local_tz_str:
        if _use_zoneinfo:
            try: local_timezone = ZoneInfo(local_tz_str)
            except Exception as e: print(f"Warning: Could not get local ZoneInfo for '{local_tz_str}': {e}")
        elif _use_pytz:
            try: local_timezone = pytz.timezone(local_tz_str)
            except Exception as e: print(f"Warning: Could not get local pytz timezone for '{local_tz_str}': {e}")
        if not local_timezone: print("Warning: Could not determine local timezone. Exact times will be shown in UTC.")

    print("\n" + "="*30); print(f"   TRANSIT ASPECTS TO NATAL"); print(f"   (Max Orb: {max_orb:.1f}¬∞, Aspects: {aspects_list})"); print("="*30)
    natal_planets = {}; transit_planets = {}; aspects_found = []

    for planet_key in planets_for_aspects:
        attr_name = next((attr for attr, key in PLANET_ATTRIBUTE_MAP.items() if key == planet_key), None);
        if not attr_name: continue
        try:
            n_planet = getattr(natal_subject, attr_name, None)
            abs_lon = _get_absolute_longitude(n_planet) # Use helper
            if abs_lon is not None: natal_planets[planet_key] = abs_lon
        except Exception as e: print(f"  - Error getting natal {planet_key}: {e}")

    for planet_key in planets_for_aspects:
        attr_name = next((attr for attr, key in PLANET_ATTRIBUTE_MAP.items() if key == planet_key), None);
        if not attr_name: continue
        try:
            t_planet = getattr(transit_subject, attr_name, None)
            abs_lon = _get_absolute_longitude(t_planet) # Use helper
            custom_speed = calculated_transit_speeds.get(planet_key)
            if abs_lon is not None:
                 transit_planets[planet_key] = {'lon': abs_lon, 'speed': custom_speed}
                 if custom_speed is None and planet_key not in ["Ascendant", "MC"]: print(f"  - Warning (T-N): Missing pre-calculated speed for transit {planet_key}.")
        except Exception as e: print(f"  - Error getting transit {planet_key}: {e}")

    if not natal_planets or not transit_planets: print("Error: Insufficient planet data (natal or transit) to calculate aspects."); return

    for tp_name, tp_data in transit_planets.items():
        if 'lon' not in tp_data: continue
        tp_lon = tp_data['lon']
        tp_speed = tp_data.get('speed')

        for np_name, np_lon in natal_planets.items():
            if tp_name == np_name: continue
            raw_diff = tp_lon - np_lon
            for aspect_angle in aspects_list:
                delta = (raw_diff - aspect_angle + 180.0 + 3600.0) % 360.0 - 180.0
                orb = abs(delta)
                if orb <= max_orb:
                    aspect_name = ASPECT_NAMES.get(aspect_angle, f"{aspect_angle}¬∞"); status = "N/A"; exact_time_str = "N/A"
                    if tp_speed is not None:
                        if abs(tp_speed) <= STATIONARY_SPEED_THRESHOLD: status = "Stationary"; exact_time_str = "Peak Now" if orb < 0.1 else "N/A"
                        else: is_applying = (delta * tp_speed <= 0); status = "Applying" if is_applying else "Separating"
                    elif tp_name in ["Ascendant", "MC"]: status = "Fast Moving"; exact_time_str = "N/A (Angle)"

                    if tp_speed is not None and abs(tp_speed) > STATIONARY_SPEED_THRESHOLD and status not in ["N/A", "Stationary", "Fast Moving"]:
                        try:
                            time_diff_days = -delta / tp_speed
                            exact_time_utc = transit_utc_dt + timedelta(days=time_diff_days)
                            if local_timezone:
                                try:
                                    exact_time_local = exact_time_utc.astimezone(local_timezone)
                                    transit_local_date = transit_utc_dt.astimezone(local_timezone).date()
                                    if exact_time_local.date() != transit_local_date: exact_time_str = exact_time_local.strftime('%m/%d %H:%M %Z')
                                    else: exact_time_str = exact_time_local.strftime('%H:%M %Z')
                                except Exception as e_tz: exact_time_str = exact_time_utc.strftime('%m/%d %H:%M UTC')
                            else:
                                if exact_time_utc.date() != transit_utc_dt.date(): exact_time_str = exact_time_utc.strftime('%m/%d %H:%M UTC')
                                else: exact_time_str = exact_time_utc.strftime('%H:%M UTC')
                        except OverflowError: exact_time_str = "Too Far"
                        except Exception as e_time: print(f"Error calculating time for {tp_name}-{aspect_name}-{np_name}: {e_time}"); exact_time_str = "Time Error"
                    aspects_found.append({'tp_name': tp_name, 'aspect_name': aspect_name, 'np_name': np_name, 'orb': orb, 'status': status, 'exact_time': exact_time_str})

    if not aspects_found: print("\nNo significant transit-to-natal aspects found within the specified orb."); return
    aspects_found.sort(key=lambda x: x['orb'])
    print(f"\n{'Transit Planet':<15} {'Aspect':<10} {'Natal Planet':<15} {'Orb':<7} {'Status':<10} {'Est. Exact':<15}")
    print("-" * 75)
    for aspect in aspects_found: orb_str = f"{aspect['orb']:.2f}¬∞"; print(f"{aspect['tp_name']:<15} {aspect['aspect_name']:<10} {aspect['np_name']:<15} {orb_str:<7} {aspect['status']:<10} {aspect['exact_time']:<15}")
    print("-" * 75)

# --- ASPECT CALCULATION FUNCTION (Transit-to-Transit) ---
# [No changes needed here, uses _get_absolute_longitude internally via setup]
def print_transit_to_transit_aspects( transit_subject: AstrologicalSubject, transit_utc_dt: datetime, aspects_list: list, max_orb: float, planets_for_aspects: list, local_tz_str: str, calculated_transit_speeds: dict ):
    """Calculates and prints aspects between planets within the transit chart itself."""
    if not transit_subject: print("\nCannot calculate transit-to-transit aspects: Transit subject missing."); return
    if not transit_utc_dt: print("\nCannot calculate aspect timing: Transit UTC datetime missing."); return
    if not calculated_transit_speeds: print("\nCannot calculate transit-to-transit aspects: Pre-calculated transit speeds missing."); return

    local_timezone = None
    if local_tz_str:
        if _use_zoneinfo:
            try: local_timezone = ZoneInfo(local_tz_str)
            except Exception as e: print(f"Warning (T-T): Could not get local ZoneInfo for '{local_tz_str}': {e}")
        elif _use_pytz:
            try: local_timezone = pytz.timezone(local_tz_str)
            except Exception as e: print(f"Warning (T-T): Could not get local pytz timezone for '{local_tz_str}': {e}")
        if not local_timezone: print("Warning (T-T): Could not determine local timezone. Exact times will be shown in UTC.")

    print("\n" + "="*30); print(f"   TRANSIT ASPECTS TO TRANSIT (Global Sentiment)"); print(f"   (Max Orb: {max_orb:.1f}¬∞, Aspects: {aspects_list})"); print("="*30)
    transit_planets = {}; aspects_found = []; processed_pairs = set()

    for planet_key in planets_for_aspects:
        attr_name = next((attr for attr, key in PLANET_ATTRIBUTE_MAP.items() if key == planet_key), None);
        if not attr_name: continue
        try:
            t_planet = getattr(transit_subject, attr_name, None)
            abs_lon = _get_absolute_longitude(t_planet) # Use helper
            custom_speed = calculated_transit_speeds.get(planet_key)
            if abs_lon is not None:
                 transit_planets[planet_key] = {'lon': abs_lon, 'speed': custom_speed}
                 if custom_speed is None and planet_key not in ["Ascendant", "MC"]: print(f"  - Warning (T-T): Missing speed for {planet_key}.")
        except Exception as e: print(f"  - Error getting transit {planet_key} for T-T aspects: {e}")

    if not transit_planets: print("Error: Insufficient transit planet data to calculate T-T aspects."); return

    for i, p1_name in enumerate(planets_for_aspects):
        p1_data = transit_planets.get(p1_name)
        if not p1_data or 'lon' not in p1_data: continue
        for j in range(i + 1, len(planets_for_aspects)):
            p2_name = planets_for_aspects[j]
            p2_data = transit_planets.get(p2_name)
            if not p2_data or 'lon' not in p2_data: continue

            pair_key = tuple(sorted((p1_name, p2_name)))
            if pair_key in processed_pairs: continue
            processed_pairs.add(pair_key)

            p1_lon = p1_data['lon']; p1_speed = p1_data.get('speed')
            p2_lon = p2_data['lon']; p2_speed = p2_data.get('speed')
            raw_diff = p1_lon - p2_lon

            for aspect_angle in aspects_list:
                delta = (raw_diff - aspect_angle + 180.0 + 3600.0) % 360.0 - 180.0
                orb = abs(delta)
                if orb <= max_orb:
                    aspect_name = ASPECT_NAMES.get(aspect_angle, f"{aspect_angle}¬∞"); status = "N/A"; exact_time_str = "N/A"
                    relative_speed = None
                    if p1_speed is not None and p2_speed is not None: relative_speed = p1_speed - p2_speed
                    elif p1_speed is not None: relative_speed = p1_speed
                    elif p2_speed is not None: relative_speed = -p2_speed

                    if relative_speed is not None:
                        if abs(relative_speed) <= STATIONARY_SPEED_THRESHOLD * 0.1: status = "Locked"; exact_time_str = "Peak Now" if orb < 0.1 else "N/A"
                        else: is_applying = (delta * relative_speed <= 0); status = "Applying" if is_applying else "Separating"

                    if relative_speed is not None and abs(relative_speed) > STATIONARY_SPEED_THRESHOLD * 0.1 and status not in ["N/A", "Locked"]:
                        try:
                            time_diff_days = -delta / relative_speed
                            exact_time_utc = transit_utc_dt + timedelta(days=time_diff_days)
                            if local_timezone:
                                try:
                                    exact_time_local = exact_time_utc.astimezone(local_timezone)
                                    transit_local_date = transit_utc_dt.astimezone(local_timezone).date()
                                    if exact_time_local.date() != transit_local_date: exact_time_str = exact_time_local.strftime('%m/%d %H:%M %Z')
                                    else: exact_time_str = exact_time_local.strftime('%H:%M %Z')
                                except Exception as e_tz: exact_time_str = exact_time_utc.strftime('%m/%d %H:%M UTC')
                            else:
                                if exact_time_utc.date() != transit_utc_dt.date(): exact_time_str = exact_time_utc.strftime('%m/%d %H:%M UTC')
                                else: exact_time_str = exact_time_utc.strftime('%H:%M UTC')
                        except OverflowError: exact_time_str = "Too Far"
                        except Exception as e_time: print(f"Error calculating time for {p1_name}-{aspect_name}-{p2_name}: {e_time}"); exact_time_str = "Time Error"
                    aspects_found.append({'p1_name': p1_name, 'aspect_name': aspect_name, 'p2_name': p2_name, 'orb': orb, 'status': status, 'exact_time': exact_time_str})

    if not aspects_found: print("\nNo significant transit-to-transit aspects found within the specified orb."); return
    aspects_found.sort(key=lambda x: x['orb'])
    print(f"\n{'Planet 1':<15} {'Aspect':<10} {'Planet 2':<15} {'Orb':<7} {'Status':<10} {'Est. Exact':<15}")
    print("-" * 75)
    for aspect in aspects_found: orb_str = f"{aspect['orb']:.2f}¬∞"; print(f"{aspect['p1_name']:<15} {aspect['aspect_name']:<10} {aspect['p2_name']:<15} {orb_str:<7} {aspect['status']:<10} {aspect['exact_time']:<15}")
    print("-" * 75)

# --- DERIVE HOUSE LORDS FUNCTION ---
# [No changes needed here, it already relies on cusp sign]
def print_derived_house_lords(subject: AstrologicalSubject, chart_type: str):
    """Calculates and prints the House Lords based on the cusp sign of each house."""
    if not subject: print(f"Warning: Cannot derive {chart_type} House Lords. Subject object is missing."); return
    print(f"\n--- {chart_type} House Lords ({house_system_name} System) ---")
    house_display_map = { 1: 'First', 2: 'Second', 3: 'Third', 4: 'Fourth', 5: 'Fifth', 6: 'Sixth', 7: 'Seventh', 8: 'Eighth', 9: 'Ninth', 10: 'Tenth', 11: 'Eleventh', 12: 'Twelfth' }
    print(f"{'House':<12} {'Cusp Sign':<10} {'House Lord':<10}")
    print("-" * 34)
    all_houses_found = True
    for i in range(1, 13):
        house_attr_name = HOUSE_NUM_TO_ATTR.get(i)
        house_display_name = house_display_map.get(i, str(i))
        cusp_sign = "N/A"; house_lord = "N/A"
        if not house_attr_name: house_lord = "Attribute Error"; all_houses_found = False
        else:
            try:
                house_obj = getattr(subject, house_attr_name, None)
                if house_obj and hasattr(house_obj, 'sign') and getattr(house_obj, 'sign', None):
                    cusp_sign = house_obj.sign
                    house_lord = ZODIAC_RULERS.get(cusp_sign, "Unknown")
                    if house_lord == "Unknown": all_houses_found = False
                else:
                    if house_obj is None: house_lord = "Attr Missing"
                    elif not hasattr(house_obj, 'sign'): house_lord = "Sign N/A"
                    else: house_lord = "Sign Empty"
                    all_houses_found = False
            except Exception as e: print(f"Error getting lord for {house_display_name} House: {e}"); cusp_sign = "Error"; house_lord = "Proc. Error"; all_houses_found = False
        print(f"{house_display_name:<12} {cusp_sign:<10} {house_lord:<10}")
    if not all_houses_found: print("Warning: Could not determine sign/lord for all houses.")
    print("-" * 34)

# --- Debug Function to Print Cusp Details ---
def debug_print_cusp_details(subject: AstrologicalSubject, chart_type: str):
    """Prints detailed attributes of house cusps for debugging."""
    if not subject: print(f"\nCannot debug cusps for {chart_type}, subject is None."); return
    print(f"\n--- Debugging {chart_type} Cusps ({house_system_name} System) ---")
    print(f"{'House':<7} {'Attr':<15} {'Sign':<5} {'Position':<10} {'SignPos (AbsLon)':<18} {'Calc SignPos':<15} {'Status'}")
    print("-" * 85) # Increased width
    calculation_possible_count = 0
    direct_sign_pos_count = 0
    for i in range(1, 13):
        attr_name = HOUSE_NUM_TO_ATTR.get(i)
        sign, pos, sign_pos, calc_sign_pos_str = "N/A", "N/A", "N/A", "N/A"
        cusp_obj = getattr(subject, attr_name, None)
        calc_possible = False
        status = "FAILED" # Default status

        if cusp_obj:
            sign = getattr(cusp_obj, 'sign', 'N/A')
            pos_val = getattr(cusp_obj, 'position', None)
            pos = f"{pos_val:.4f}" if pos_val is not None else "N/A"
            sign_pos_val = getattr(cusp_obj, 'sign_pos', None)
            sign_pos = f"{sign_pos_val:.4f}" if sign_pos_val is not None else "MISSING/None"

            if sign_pos_val is not None:
                direct_sign_pos_count += 1
                status = "OK"

            # Attempt manual calculation for comparison/verification
            if sign != 'N/A' and pos_val is not None:
                 sign_start_lon = SIGN_START_LONGITUDES.get(sign)
                 if sign_start_lon is not None:
                     calc_sign_pos = (sign_start_lon + pos_val) % 360.0
                     calc_sign_pos_str = f"{calc_sign_pos:.4f}"
                     if sign_pos_val is None: # If original sign_pos was missing AND we could calculate
                         calculation_possible_count += 1
                         calc_possible = True
                         status = "WORKAROUND" # Status becomes WORKAROUND only if needed and possible
                 else: calc_sign_pos_str = "NoSignStart"
            else: calc_sign_pos_str = "NoSign/Pos"

        else:
            attr_name = "Obj Missing"

        print(f"{i:<7} {attr_name:<15} {sign:<5} {pos:<10} {sign_pos:<18} {calc_sign_pos_str:<15} {status}")

    print("-" * 85) # Increased width
    print(f"Summary: Direct sign_pos available for {direct_sign_pos_count}/12 cusps.")
    print(f"Summary: Fallback calculation possible for {calculation_possible_count}/12 cusps (where direct sign_pos was missing).")
    if (direct_sign_pos_count + calculation_possible_count) == 12 :
         print("--> House placement calculation SHOULD be possible.")
    else:
         print(f"--> House placement calculation likely IMPOSSIBLE due to missing base cusp data (sign/position) for {12 - (direct_sign_pos_count + calculation_possible_count)} cusps.")


# --- MAIN EXECUTION ---
if __name__ == "__main__":
    print("--- ASTROLOGICAL ANALYSIS SCRIPT ---")
    print(f"Natal: {natal_name} ({natal_day}-{natal_month}-{natal_year} {natal_hour_local}:{natal_minute_local:02d})")
    print(f"Transit: {transit_name} ({transit_day}-{transit_month}-{transit_year} {transit_hour_local}:{transit_minute_local:02d})")
    print(f"Location: {location_city}, {location_nation} ({location_timezone_str})")
    print(f"Settings: {zodiac_type} ({ayanamsa}), {house_system_name} Houses")
    print("-" * 40)

    print("Calculating UTC times...")
    natal_utc_dt = get_utc_datetime( natal_year, natal_month, natal_day, natal_hour_local, natal_minute_local, location_timezone_str)
    transit_utc_dt = get_utc_datetime( transit_year, transit_month, transit_day, transit_hour_local, transit_minute_local, location_timezone_str)
    if not natal_utc_dt or not transit_utc_dt:
         print("Error: Could not calculate required UTC times. Exiting.")
         exit(1)
    print(f"Natal UTC: {natal_utc_dt}")
    print(f"Transit UTC: {transit_utc_dt}")

    print("\nCreating AstrologicalSubject instances...")
    natal_subject = None; transit_subject = None
    try:
        natal_subject = AstrologicalSubject(
            name=natal_name, year=natal_utc_dt.year, month=natal_utc_dt.month, day=natal_utc_dt.day,
            hour=natal_utc_dt.hour, minute=natal_utc_dt.minute,
            city=location_city, nation=location_nation, lat=location_latitude, lng=location_longitude,
            tz_str=location_timezone_str, zodiac_type=zodiac_type, sidereal_mode=ayanamsa,
            houses_system_identifier=house_system_identifier, online=KERYKEION_ONLINE_MODE
        )
        print(f"- Successfully created: {natal_subject.name}")
    except Exception as e: print(f"Error creating Natal AstrologicalSubject: {e}"); traceback.print_exc()

    try:
        transit_subject = AstrologicalSubject(
            name=transit_name, year=transit_utc_dt.year, month=transit_utc_dt.month, day=transit_utc_dt.day,
            hour=transit_utc_dt.hour, minute=transit_utc_dt.minute,
            city=location_city, nation=location_nation, lat=location_latitude, lng=location_longitude,
            tz_str=location_timezone_str, zodiac_type=zodiac_type, sidereal_mode=ayanamsa,
            houses_system_identifier=house_system_identifier, online=KERYKEION_ONLINE_MODE
        )
        print(f"- Successfully created: {transit_subject.name}")
    except Exception as e: print(f"Error creating Transit AstrologicalSubject: {e}"); traceback.print_exc()

    # --- Optional: Add Cusp Debugging ---
    if natal_subject:
        debug_print_cusp_details(natal_subject, "Natal")
    if transit_subject:
        debug_print_cusp_details(transit_subject, "Transit")
    # --- End Cusp Debugging ---


    calculated_transit_speeds = None
    if transit_subject:
        print("\nCalculating Transit Planetary Speeds...")
        try:
            calculated_transit_speeds = calculate_custom_speeds(transit_subject)
            if calculated_transit_speeds: print_planetary_speeds(calculated_transit_speeds, transit_subject)
            else: print("... Speed calculation failed.")
        except Exception as e: print(f"Error during speed calculation: {e}"); traceback.print_exc()
    else: print("\nSkipping speed calculation (Transit Subject creation failed).")

    # --- Natal Chart Details ---
    if natal_subject:
        print("\n" + "="*30); print(f"   NATAL CHART: {natal_name}"); print(f"   ({house_system_name} Houses, {ayanamsa} Ayanamsa)"); print("="*30)
        try: natal_report_obj = Report(natal_subject); natal_report_obj.print_report(); print("-" * 70)
        except Exception as e: print(f"\nError generating standard Natal Report: {e}"); traceback.print_exc()
        try: print_derived_house_lords(natal_subject, "Natal")
        except Exception as e: print(f"\nError printing Derived Natal House Lords: {e}"); traceback.print_exc()
        try: print_nakshatras(natal_subject, "Natal")
        except Exception as e: print(f"\nError printing Natal Nakshatras: {e}")

        # --- Print Natal Divisional Charts using the Wrapper ---
        print_all_divisional_charts(natal_subject, "Natal")

    else: print("\nSkipping Natal Report details (Subject creation failed).")

    # --- Transit Chart Details ---
    if transit_subject:
        print("\n" + "="*30); print(f"   TRANSIT CHART: {transit_name}"); print(f"   ({house_system_name} Houses, {ayanamsa} Ayanamsa)"); print("="*30)
        try: transit_report_obj = Report(transit_subject); transit_report_obj.print_report(); print("-" * 70)
        except Exception as e: print(f"\nError generating standard Transit Report: {e}"); traceback.print_exc()
        try: print_derived_house_lords(transit_subject, "Transit")
        except Exception as e: print(f"\nError printing Derived Transit House Lords: {e}"); traceback.print_exc()
        try: print_nakshatras(transit_subject, "Transit")
        except Exception as e: print(f"\nError printing Transit Nakshatras: {e}")

        # --- Print Transit Divisional Charts using the Wrapper ---
        print_all_divisional_charts(transit_subject, "Transit")

    else: print("\nSkipping Transit Report details (Subject creation failed).")

    # --- Aspect Calculations ---
    if natal_subject and transit_subject and transit_utc_dt and calculated_transit_speeds:
        try:
            print_manual_transit_aspects(natal_subject, transit_subject, transit_utc_dt, ASPECTS_TO_CHECK, MAX_ASPECT_ORB, PLANETS_FOR_ASPECTS, location_timezone_str, calculated_transit_speeds)
        except Exception as e: print(f"\nError calculating/printing Transit-to-Natal Aspects: {e}"); traceback.print_exc()
    else:
        missing_deps = [dep for dep, val in [("Natal Subject", natal_subject), ("Transit Subject", transit_subject), ("Transit UTC Time", transit_utc_dt), ("Transit Speeds", calculated_transit_speeds)] if not val]
        if missing_deps: print(f"\nSkipping Transit-to-Natal Aspect calculation (Missing: {', '.join(missing_deps)}).")

    if transit_subject and transit_utc_dt and calculated_transit_speeds:
        try:
            print_transit_to_transit_aspects(transit_subject, transit_utc_dt, ASPECTS_TO_CHECK, MAX_TRANSIT_ASPECT_ORB, PLANETS_FOR_TRANSIT_ASPECTS, location_timezone_str, calculated_transit_speeds)
        except Exception as e: print(f"\nError calculating/printing Transit-to-Transit Aspects: {e}"); traceback.print_exc()
    else:
        missing_deps = [dep for dep, val in [("Transit Subject", transit_subject), ("Transit UTC Time", transit_utc_dt), ("Transit Speeds", calculated_transit_speeds)] if not val]
        if missing_deps: print(f"\nSkipping Transit-to-Transit Aspect calculation (Missing: {', '.join(missing_deps)}).")

    print("\nScript finished.")
